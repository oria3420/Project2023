{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nconst dns = require(\"dns\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\nclass GSSAPI extends auth_provider_1.AuthProvider {\n  auth(authContext, callback) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n    if (credentials == null) return callback(new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication'));\n    const {\n      username\n    } = credentials;\n    function externalCommand(command, cb) {\n      return connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined, cb);\n    }\n    makeKerberosClient(authContext, (err, client) => {\n      if (err) return callback(err);\n      if (client == null) return callback(new error_1.MongoMissingDependencyError('GSSAPI client missing'));\n      client.step('', (err, payload) => {\n        if (err) return callback(err);\n        externalCommand(saslStart(payload), (err, result) => {\n          if (err) return callback(err);\n          if (result == null) return callback();\n          negotiate(client, 10, result.payload, (err, payload) => {\n            if (err) return callback(err);\n            externalCommand(saslContinue(payload, result.conversationId), (err, result) => {\n              if (err) return callback(err);\n              if (result == null) return callback();\n              finalize(client, username, result.payload, (err, payload) => {\n                if (err) return callback(err);\n                externalCommand({\n                  saslContinue: 1,\n                  conversationId: result.conversationId,\n                  payload\n                }, (err, result) => {\n                  if (err) return callback(err);\n                  callback(undefined, result);\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n}\nexports.GSSAPI = GSSAPI;\nfunction makeKerberosClient(authContext, callback) {\n  const {\n    hostAddress\n  } = authContext.options;\n  const {\n    credentials\n  } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    return callback(new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.'));\n  }\n  if ('kModuleError' in deps_1.Kerberos) {\n    return callback(deps_1.Kerberos['kModuleError']);\n  }\n  const {\n    initializeClient\n  } = deps_1.Kerberos;\n  const {\n    username,\n    password\n  } = credentials;\n  const mechanismProperties = credentials.mechanismProperties;\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n  performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties, (err, host) => {\n    if (err) return callback(err);\n    const initOptions = {};\n    if (password != null) {\n      Object.assign(initOptions, {\n        user: username,\n        password: password\n      });\n    }\n    const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n    if ('SERVICE_REALM' in mechanismProperties) {\n      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n    }\n    initializeClient(spn, initOptions, (err, client) => {\n      // TODO(NODE-3483)\n      if (err) return callback(new error_1.MongoRuntimeError(err));\n      callback(undefined, client);\n    });\n  });\n}\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\nfunction negotiate(client, retries, payload, callback) {\n  client.step(payload, (err, response) => {\n    // Retries exhausted, raise error\n    if (err && retries === 0) return callback(err);\n    // Adjust number of retries and call step again\n    if (err) return negotiate(client, retries - 1, payload, callback);\n    // Return the payload\n    callback(undefined, response || '');\n  });\n}\nfunction finalize(client, user, payload, callback) {\n  // GSS Client Unwrap\n  client.unwrap(payload, (err, response) => {\n    if (err) return callback(err);\n    // Wrap the response\n    client.wrap(response || '', {\n      user\n    }, (err, wrapped) => {\n      if (err) return callback(err);\n      // Return the payload\n      callback(undefined, wrapped);\n    });\n  });\n}\nfunction performGSSAPICanonicalizeHostName(host, mechanismProperties, callback) {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n    return callback(undefined, host);\n  }\n  // If forward and reverse or true\n  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n    // Perform the lookup of the ip address.\n    dns.lookup(host, (error, address) => {\n      // No ip found, return the error.\n      if (error) return callback(error);\n      // Perform a reverse ptr lookup on the ip address.\n      dns.resolvePtr(address, (err, results) => {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        if (err) {\n          return resolveCname(host, callback);\n        }\n        // If the ptr did not error but had no results, return the host.\n        callback(undefined, results.length > 0 ? results[0] : host);\n      });\n    });\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    resolveCname(host, callback);\n  }\n}\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nfunction resolveCname(host, callback) {\n  // Attempt to resolve the host name\n  dns.resolveCname(host, (err, r) => {\n    if (err) return callback(undefined, host);\n    // Get the first resolve host id\n    if (r.length > 0) {\n      return callback(undefined, r[0]);\n    }\n    callback(undefined, host);\n  });\n}\nexports.resolveCname = resolveCname;","map":{"version":3,"names":["dns","require","deps_1","error_1","utils_1","auth_provider_1","exports","GSSAPICanonicalizationValue","Object","freeze","on","off","none","forward","forwardAndReverse","GSSAPI","AuthProvider","auth","authContext","callback","connection","credentials","MongoMissingCredentialsError","username","externalCommand","command","cb","ns","undefined","makeKerberosClient","err","client","MongoMissingDependencyError","step","payload","saslStart","result","negotiate","saslContinue","conversationId","finalize","hostAddress","options","host","MongoInvalidArgumentError","Kerberos","initializeClient","password","mechanismProperties","serviceName","SERVICE_NAME","performGSSAPICanonicalizeHostName","initOptions","assign","user","spnHost","SERVICE_HOST","spn","process","platform","SERVICE_REALM","MongoRuntimeError","mechanism","autoAuthorize","retries","response","unwrap","wrap","wrapped","mode","CANONICALIZE_HOST_NAME","lookup","error","address","resolvePtr","results","resolveCname","length","r"],"sources":["C:\\Users\\oria3\\node_modules\\mongodb\\src\\cmap\\auth\\gssapi.ts"],"sourcesContent":["import * as dns from 'dns';\n\nimport type { Document } from '../../bson';\nimport { Kerberos, KerberosClient } from '../../deps';\nimport {\n  MongoError,\n  MongoInvalidArgumentError,\n  MongoMissingCredentialsError,\n  MongoMissingDependencyError,\n  MongoRuntimeError\n} from '../../error';\nimport { Callback, ns } from '../../utils';\nimport { AuthContext, AuthProvider } from './auth_provider';\n\n/** @public */\nexport const GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n} as const);\n\n/** @public */\nexport type GSSAPICanonicalizationValue =\n  typeof GSSAPICanonicalizationValue[keyof typeof GSSAPICanonicalizationValue];\n\ntype MechanismProperties = {\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n};\n\nexport class GSSAPI extends AuthProvider {\n  override auth(authContext: AuthContext, callback: Callback): void {\n    const { connection, credentials } = authContext;\n    if (credentials == null)\n      return callback(\n        new MongoMissingCredentialsError('Credentials required for GSSAPI authentication')\n      );\n    const { username } = credentials;\n    function externalCommand(\n      command: Document,\n      cb: Callback<{ payload: string; conversationId: any }>\n    ) {\n      return connection.command(ns('$external.$cmd'), command, undefined, cb);\n    }\n    makeKerberosClient(authContext, (err, client) => {\n      if (err) return callback(err);\n      if (client == null) return callback(new MongoMissingDependencyError('GSSAPI client missing'));\n      client.step('', (err, payload) => {\n        if (err) return callback(err);\n\n        externalCommand(saslStart(payload), (err, result) => {\n          if (err) return callback(err);\n          if (result == null) return callback();\n          negotiate(client, 10, result.payload, (err, payload) => {\n            if (err) return callback(err);\n\n            externalCommand(saslContinue(payload, result.conversationId), (err, result) => {\n              if (err) return callback(err);\n              if (result == null) return callback();\n              finalize(client, username, result.payload, (err, payload) => {\n                if (err) return callback(err);\n\n                externalCommand(\n                  {\n                    saslContinue: 1,\n                    conversationId: result.conversationId,\n                    payload\n                  },\n                  (err, result) => {\n                    if (err) return callback(err);\n\n                    callback(undefined, result);\n                  }\n                );\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n}\n\nfunction makeKerberosClient(authContext: AuthContext, callback: Callback<KerberosClient>): void {\n  const { hostAddress } = authContext.options;\n  const { credentials } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    return callback(\n      new MongoInvalidArgumentError('Connection must have host and port and credentials defined.')\n    );\n  }\n\n  if ('kModuleError' in Kerberos) {\n    return callback(Kerberos['kModuleError']);\n  }\n  const { initializeClient } = Kerberos;\n\n  const { username, password } = credentials;\n  const mechanismProperties = credentials.mechanismProperties as MechanismProperties;\n\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n\n  performGSSAPICanonicalizeHostName(\n    hostAddress.host,\n    mechanismProperties,\n    (err?: Error | MongoError, host?: string) => {\n      if (err) return callback(err);\n\n      const initOptions = {};\n      if (password != null) {\n        Object.assign(initOptions, { user: username, password: password });\n      }\n\n      const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n      let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n      if ('SERVICE_REALM' in mechanismProperties) {\n        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n      }\n\n      initializeClient(spn, initOptions, (err: string, client: KerberosClient): void => {\n        // TODO(NODE-3483)\n        if (err) return callback(new MongoRuntimeError(err));\n        callback(undefined, client);\n      });\n    }\n  );\n}\n\nfunction saslStart(payload?: string): Document {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\n\nfunction saslContinue(payload?: string, conversationId?: number): Document {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\n\nfunction negotiate(\n  client: KerberosClient,\n  retries: number,\n  payload: string,\n  callback: Callback<string>\n): void {\n  client.step(payload, (err, response) => {\n    // Retries exhausted, raise error\n    if (err && retries === 0) return callback(err);\n\n    // Adjust number of retries and call step again\n    if (err) return negotiate(client, retries - 1, payload, callback);\n\n    // Return the payload\n    callback(undefined, response || '');\n  });\n}\n\nfunction finalize(\n  client: KerberosClient,\n  user: string,\n  payload: string,\n  callback: Callback<string>\n): void {\n  // GSS Client Unwrap\n  client.unwrap(payload, (err, response) => {\n    if (err) return callback(err);\n\n    // Wrap the response\n    client.wrap(response || '', { user }, (err, wrapped) => {\n      if (err) return callback(err);\n\n      // Return the payload\n      callback(undefined, wrapped);\n    });\n  });\n}\n\nexport function performGSSAPICanonicalizeHostName(\n  host: string,\n  mechanismProperties: MechanismProperties,\n  callback: Callback<string>\n): void {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === GSSAPICanonicalizationValue.none) {\n    return callback(undefined, host);\n  }\n\n  // If forward and reverse or true\n  if (\n    mode === GSSAPICanonicalizationValue.on ||\n    mode === GSSAPICanonicalizationValue.forwardAndReverse\n  ) {\n    // Perform the lookup of the ip address.\n    dns.lookup(host, (error, address) => {\n      // No ip found, return the error.\n      if (error) return callback(error);\n\n      // Perform a reverse ptr lookup on the ip address.\n      dns.resolvePtr(address, (err, results) => {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        if (err) {\n          return resolveCname(host, callback);\n        }\n        // If the ptr did not error but had no results, return the host.\n        callback(undefined, results.length > 0 ? results[0] : host);\n      });\n    });\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    resolveCname(host, callback);\n  }\n}\n\nexport function resolveCname(host: string, callback: Callback<string>): void {\n  // Attempt to resolve the host name\n  dns.resolveCname(host, (err, r) => {\n    if (err) return callback(undefined, host);\n\n    // Get the first resolve host id\n    if (r.length > 0) {\n      return callback(undefined, r[0]);\n    }\n\n    callback(undefined, host);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}